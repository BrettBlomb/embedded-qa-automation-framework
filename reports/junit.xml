<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="5" skipped="0" tests="9" time="10.832" timestamp="2025-12-03T09:40:31.638973-08:00" hostname="DESKTOP-TTGBS3N"><testcase classname="tests.api.test_coap_device" name="test_coap_get_resource_status_code" time="0.600"><failure message="aiocoap.error.NetworkError: Network error: NetworkError">self = &lt;_ProactorDatagramTransport fd=644&gt;
fut = &lt;_OverlappedFuture finished exception=OSError(22, 'No service is operating at the destination network endpoint on the remote system', None, 1234, None)&gt;

    def _loop_reading(self, fut=None):
        data = None
        try:
            if self._conn_lost:
                return
    
            assert self._read_fut is fut or (self._read_fut is None and
                                             self._closing)
    
            self._read_fut = None
            if fut is not None:
&gt;               res = fut.result()
                      ^^^^^^^^^^^^

..\AppData\Local\Programs\Python\Python314\Lib\asyncio\proactor_events.py:558: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
..\AppData\Local\Programs\Python\Python314\Lib\asyncio\windows_events.py:804: in _poll
    value = callback(transferred, key, ov)
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

trans = 0, key = 0, ov = &lt;_overlapped.Overlapped object at 0x0000026BB62B25B0&gt;

    @staticmethod
    def finish_socket_func(trans, key, ov):
        try:
&gt;           return ov.getresult()
                   ^^^^^^^^^^^^^^
E           OSError: [WinError 1234] No service is operating at the destination network endpoint on the remote system

..\AppData\Local\Programs\Python\Python314\Lib\asyncio\windows_events.py:463: OSError

The above exception was the direct cause of the following exception:

    def test_coap_get_resource_status_code():
        """Verify that CoAP GET returns a 2.xx success code for a resource."""
        client = CoapClient()
&gt;       response = client.get_resource_sync("status")
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\api\test_coap_device.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
framework\coap_client.py:34: in get_resource_sync
    return asyncio.run(self.get_resource(path))
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\AppData\Local\Programs\Python\Python314\Lib\asyncio\runners.py:204: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
..\AppData\Local\Programs\Python\Python314\Lib\asyncio\runners.py:127: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
..\AppData\Local\Programs\Python\Python314\Lib\asyncio\base_events.py:719: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
framework\coap_client.py:26: in get_resource
    return await self._send_request(GET, path)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
framework\coap_client.py:21: in _send_request
    response = await protocol.request(request).response
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\aiocoap\protocol.py:768: in _run_outer
    await cls._run(app_request, response, weak_observation, protocol, log)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cls = &lt;class 'aiocoap.protocol.BlockwiseRequest'&gt;
app_request = &lt;aiocoap.Message: GET to &lt;_Connection at 0x26bb634dd30 on transport &lt;_ProactorDatagramTransport fd=644&gt;, active&gt;, 2 option(s), token 4353, CON, MID 0xf57c&gt;
response = &lt;Future finished exception=NetworkError('[WinError 1234] No service is operating at the destination network endpoint on the remote system')&gt;
weak_observation = &lt;function BlockwiseRequest.__init__.&lt;locals&gt;.&lt;lambda&gt; at 0x0000026BB63DE820&gt;
protocol = &lt;aiocoap.protocol.Context object at 0x0000026BB634C6E0&gt;, log = &lt;Logger coap.blockwise-requester (WARNING)&gt;

    @classmethod
    async def _run(cls, app_request, response, weak_observation, protocol, log):
        # we need to populate the remote right away, because the choice of
        # blocks depends on it.
        await protocol.find_remote_and_interface(app_request)
    
        size_exp = app_request.remote.maximum_block_size_exp
    
        if app_request.opt.block1 is not None:
            warnings.warn(
                "Setting a block1 option in a managed block-wise transfer is deprecated. Instead, set request.remote.maximum_block_size_exp to the desired value",
                DeprecationWarning,
                stacklevel=2,
            )
            assert app_request.opt.block1.block_number == 0, (
                "Unexpected block number in app_request"
            )
            assert not app_request.opt.block1.more, (
                "Unexpected more-flag in app_request"
            )
            # this is where the library user can traditionally pass in size
            # exponent hints into the library.
            size_exp = app_request.opt.block1.size_exponent
    
        # Offset in the message in blocks of size_exp. Whoever changes size_exp
        # is responsible for updating this number.
        block_cursor = 0
    
        while True:
            # ... send a chunk
    
            if size_exp &gt;= 6:
                # FIXME from maximum_payload_size
                fragmentation_threshold = app_request.remote.maximum_payload_size
            else:
                fragmentation_threshold = 2 ** (size_exp + 4)
    
            if (
                app_request.opt.block1 is not None
                or len(app_request.payload) &gt; fragmentation_threshold
            ):
                current_block1 = app_request._extract_block(
                    block_cursor, size_exp, app_request.remote.maximum_payload_size
                )
                if block_cursor == 0:
                    current_block1.opt.size1 = len(app_request.payload)
            else:
                current_block1 = app_request
    
            blockrequest = protocol.request(current_block1, handle_blockwise=False)
&gt;           blockresponse = await blockrequest.response
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           aiocoap.error.NetworkError: Network error: NetworkError

venv\Lib\site-packages\aiocoap\protocol.py:843: NetworkError</failure></testcase><testcase classname="tests.api.test_rest_health" name="test_health_endpoint_returns_200" time="0.706"><failure message="assert 503 == 200&#10; +  where 503 = &lt;Response [503]&gt;.status_code">def test_health_endpoint_returns_200():
        """Verify that the health endpoint responds with 200 OK."""
        client = ApiClient()
        response = client.get_health()
&gt;       assert response.status_code == 200
E       assert 503 == 200
E        +  where 503 = &lt;Response [503]&gt;.status_code

tests\api\test_rest_health.py:9: AssertionError</failure></testcase><testcase classname="tests.embedded.test_firmware_sim" name="test_tcp_echo_server_round_trip" time="0.109" /><testcase classname="tests.network.test_tcp_udp" name="test_tcp_handshake_succeeds_for_localhost" time="0.024" /><testcase classname="tests.network.test_tcp_udp" name="test_udp_message_received_by_server" time="0.003"><failure message="assert ([])">def test_udp_message_received_by_server():
        """Verify a UDP message is received by a simple UDP server."""
        host, port = "127.0.0.1", 9300
        buffer = []
        thread = threading.Thread(target=_udp_server, args=(host, port, buffer), daemon=True)
        thread.start()
    
        send_udp_message(host, port, b"hello_udp")
    
        # crudely wait for message
        for _ in range(10_000):
            if buffer:
                break
    
&gt;       assert buffer and buffer[0] == b"hello_udp"
E       assert ([])

tests\network\test_tcp_udp.py:42: AssertionError</failure></testcase><testcase classname="tests.security.test_ssl_cert" name="test_ssl_certificate_valid_for_example_com" time="0.276" /><testcase classname="tests.security.test_ssl_cert" name="test_ssl_certificate_has_subject" time="0.196" /><testcase classname="tests.ui.test_login" name="test_login_page_title_contains_login" time="4.317"><failure message="assert 'Login' in 'Example Domain'&#10; +  where 'Example Domain' = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session=&quot;a93fa9352309ecb558467bf1b597654b&quot;)&gt;.title">def test_login_page_title_contains_login():
        """Verify that the login page title contains the word 'Login'."""
        driver = webdriver.Chrome()  # Jenkins node will need chromedriver
        try:
            driver.get(get_selenium_base_url() + "/login")
&gt;           assert "Login" in driver.title
E           assert 'Login' in 'Example Domain'
E            +  where 'Example Domain' = &lt;selenium.webdriver.chrome.webdriver.WebDriver (session="a93fa9352309ecb558467bf1b597654b")&gt;.title

tests\ui\test_login.py:12: AssertionError</failure></testcase><testcase classname="tests.ui.test_login" name="test_login_form_has_username_and_password_fields" time="3.800"><failure message="selenium.common.exceptions.NoSuchElementException: Message: no such element: Unable to locate element: {&quot;method&quot;:&quot;css selector&quot;,&quot;selector&quot;:&quot;[name=&quot;username&quot;]&quot;}&#10;  (Session info: chrome=142.0.7444.176); For documentation on this error, please visit: https://www.selenium.dev/documentation/webdriver/troubleshooting/errors#nosuchelementexception&#10;Stacktrace:&#10;Symbols not available. Dumping unresolved backtrace:&#10;&#09;0x7ff64c4ba235&#10;&#09;0x7ff64c212630&#10;&#09;0x7ff64bfa16dd&#10;&#09;0x7ff64bffa27e&#10;&#09;0x7ff64bffa58c&#10;&#09;0x7ff64c04ed77&#10;&#09;0x7ff64c04baba&#10;&#09;0x7ff64bfeb0ed&#10;&#09;0x7ff64bfebf63&#10;&#09;0x7ff64c4e5d60&#10;&#09;0x7ff64c4dfe8a&#10;&#09;0x7ff64c501005&#10;&#09;0x7ff64c22d71e&#10;&#09;0x7ff64c234e1f&#10;&#09;0x7ff64c21b7c4&#10;&#09;0x7ff64c21b97f&#10;&#09;0x7ff64c2018e8&#10;&#09;0x7ffdafe0e8d7&#10;&#09;0x7ffdb098c53c">def test_login_form_has_username_and_password_fields():
        """Verify login form contains username and password fields."""
        driver = webdriver.Chrome()
        try:
            driver.get(get_selenium_base_url() + "/login")
&gt;           username = driver.find_element(By.NAME, "username")
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\ui\test_login.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
venv\Lib\site-packages\selenium\webdriver\remote\webdriver.py:926: in find_element
    return self.execute(Command.FIND_ELEMENT, {"using": by, "value": value})["value"]
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
venv\Lib\site-packages\selenium\webdriver\remote\webdriver.py:458: in execute
    self.error_handler.check_response(response)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;selenium.webdriver.remote.errorhandler.ErrorHandler object at 0x0000026BB6402E90&gt;
response = {'status': 404, 'value': '{"value":{"error":"no such element","message":"no such element: Unable to locate element: {\...ff64c234e1f\\n\\t0x7ff64c21b7c4\\n\\t0x7ff64c21b97f\\n\\t0x7ff64c2018e8\\n\\t0x7ffdafe0e8d7\\n\\t0x7ffdb098c53c\\n"}}'}

    def check_response(self, response: dict[str, Any]) -&gt; None:
        """Checks that a JSON response from the WebDriver does not have an
        error.
    
        Args:
            response: The JSON response from the WebDriver server as a dictionary
                object.
    
        Raises:
            WebDriverException: If the response contains an error message.
        """
        status = response.get("status", None)
        if not status or status == ErrorCode.SUCCESS:
            return
        value = None
        message = response.get("message", "")
        screen: str = response.get("screen", "")
        stacktrace = None
        if isinstance(status, int):
            value_json = response.get("value", None)
            if value_json and isinstance(value_json, str):
                try:
                    value = json.loads(value_json)
                    if isinstance(value, dict):
                        if len(value) == 1:
                            value = value["value"]
                        status = value.get("error", None)
                        if not status:
                            status = value.get("status", ErrorCode.UNKNOWN_ERROR)
                            message = value.get("value") or value.get("message")
                            if not isinstance(message, str):
                                value = message
                                message = message.get("message") if isinstance(message, dict) else None
                        else:
                            message = value.get("message", None)
                except ValueError:
                    pass
    
        exception_class: type[WebDriverException]
        e = ErrorCode()
        error_codes = [item for item in dir(e) if not item.startswith("__")]
        for error_code in error_codes:
            error_info = getattr(ErrorCode, error_code)
            if isinstance(error_info, list) and status in error_info:
                exception_class = getattr(ExceptionMapping, error_code, WebDriverException)
                break
        else:
            exception_class = WebDriverException
    
        if not value:
            value = response["value"]
        if isinstance(value, str):
            raise exception_class(value)
        if message == "" and "message" in value:
            message = value["message"]
    
        screen = None  # type: ignore[assignment]
        if "screen" in value:
            screen = value["screen"]
    
        stacktrace = None
        st_value = value.get("stackTrace") or value.get("stacktrace")
        if st_value:
            if isinstance(st_value, str):
                stacktrace = st_value.split("\n")
            else:
                stacktrace = []
                try:
                    for frame in st_value:
                        line = frame.get("lineNumber", "")
                        file = frame.get("fileName", "&lt;anonymous&gt;")
                        if line:
                            file = f"{file}:{line}"
                        meth = frame.get("methodName", "&lt;anonymous&gt;")
                        if "className" in frame:
                            meth = f"{frame['className']}.{meth}"
                        msg = "    at %s (%s)"
                        msg = msg % (meth, file)
                        stacktrace.append(msg)
                except TypeError:
                    pass
        if exception_class == UnexpectedAlertPresentException:
            alert_text = None
            if "data" in value:
                alert_text = value["data"].get("text")
            elif "alert" in value:
                alert_text = value["alert"].get("text")
            raise exception_class(message, screen, stacktrace, alert_text)  # type: ignore[call-arg]  # mypy is not smart enough here
&gt;       raise exception_class(message, screen, stacktrace)
E       selenium.common.exceptions.NoSuchElementException: Message: no such element: Unable to locate element: {"method":"css selector","selector":"[name="username"]"}
E         (Session info: chrome=142.0.7444.176); For documentation on this error, please visit: https://www.selenium.dev/documentation/webdriver/troubleshooting/errors#nosuchelementexception
E       Stacktrace:
E       Symbols not available. Dumping unresolved backtrace:
E       	0x7ff64c4ba235
E       	0x7ff64c212630
E       	0x7ff64bfa16dd
E       	0x7ff64bffa27e
E       	0x7ff64bffa58c
E       	0x7ff64c04ed77
E       	0x7ff64c04baba
E       	0x7ff64bfeb0ed
E       	0x7ff64bfebf63
E       	0x7ff64c4e5d60
E       	0x7ff64c4dfe8a
E       	0x7ff64c501005
E       	0x7ff64c22d71e
E       	0x7ff64c234e1f
E       	0x7ff64c21b7c4
E       	0x7ff64c21b97f
E       	0x7ff64c2018e8
E       	0x7ffdafe0e8d7
E       	0x7ffdb098c53c

venv\Lib\site-packages\selenium\webdriver\remote\errorhandler.py:233: NoSuchElementException</failure></testcase></testsuite></testsuites>